const Discord = require("discord.js");
const client = new Discord.Client();




client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
client.user.setGame(`Nothing...`,"http://twitch.tv/Mohamed192837465")
  console.log('')
  console.log('')
  console.log('â•”[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•—')
  console.log(`[Start] ${new Date()}`);
  console.log('â•š[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•')
  console.log('')
  console.log('â•”[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•—');
  console.log(`Logged in as * [ " ${client.user.username} " ]`);
  console.log('')
  console.log('Informations :')
  console.log('')
  console.log(`servers! [ " ${client.guilds.size} " ]`);
  console.log(`Users! [ " ${client.users.size} " ]`);
  console.log(`channels! [ " ${client.channels.size} " ]`);
  console.log('â•š[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•')
  console.log('')
  console.log('â•”[â•â•â•â•â•â•â•â•â•â•â•â•]â•—')
  console.log(' Bot Is Online')
  console.log('â•š[â•â•â•â•â•â•â•â•â•â•â•â•]â•')
  console.log('')
  console.log('')
});


client.on('message', msg => {
  if (msg.content === 'ping') {
    msg.reply('Pong!');
  }
});


client.on('message', message=> {
    if (message.author.bot) return;
    if (message.isMentioned(client.user))
    {
    message.reply(" ÙŠØ§Ù„ÙŠÙŠÙŠÙ„ Ø´ØªØ¨ÙŠÙŠ!!");
    }
});

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47

client.on('message', message => {
    if (message.content === "$id") {
    let embed = new Discord.RichEmbed()
   .setColor("RANDOM")
   .setThumbnail(message.author.avatarURL)
   .setTitle(`info about ${message.guild.name}`)
   .addField("Server Owner ğŸ‘‘",`â¥ ` + `${message.guild.owner.user.username}`, true)
   .addField('Server ID ğŸ†”',`â¥` + message.guild.id, true)
   .addField("Owner Tag",`â¥ ` +  `#` + message.guild.owner.user.discriminator, true)
   .addField("Owner ID ğŸ†”",`â¥ ` + message.guild.owner.user.id, true)
   .addField("Server RegionğŸ“¡",`â¥ ` + message.guild.region, true)
   .addField("Server Member SizeğŸ§",`â¥ ` + message.guild.members.size, true)
   .addField("Server Channels NumberğŸ§",`â¥ ` + message.guild.channels.size, true)
   .addField("Server Roels NumberğŸ§",`â¥ ` + message.guild.roles.size, true)
   .addField("AFK channelğŸ’¤",`â¥ ` + message.guild.afkChannel || 'Null', true)
   .addField("Server Created AT",`â¥ ` + message.guild.createdAt, true)
   .addField(`info about ${message.author.username}`, `â¥ `)
   .addField("Name",`â¥ ` + `${message.author.username}`, true)
   .addField('Tag',`â¥ ` + "#" +  message.author.discriminator, true)
   .addField("ID ğŸ†”",`â¥ ` + message.author.id, true)
   .addField(" Account Created At",`â¥ ` + message.author.createdAt, true)
   .setTimestamp()
   .setFooter(message.author.tag, message.author.avatarURL)
      
      
   message.channel.sendEmbed(embed);
     }
 });
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47

client.on('message' , message => {;
  if(message.author.bot) return;

    if(message.content.startsWith('$xo')) {
 let array_of_mentions = message.mentions.users.array();
  let symbols = [':o:', ':heavy_multiplication_x:'] 
  var grid_message;

  if (array_of_mentions.length == 1 || array_of_mentions.length == 2) {
    let random1 = Math.floor(Math.random() * (1 - 0 + 1)) + 0;
    let random2 = Math.abs(random1 - 1); 
    if (array_of_mentions.length == 1) {
      random1 = 0;
      random2 = 0;
    }
    let player1_id = array_of_mentions[random1].id;
    let player2_id = array_of_mentions[random2].id;
    var turn_id = player1_id;
    var symbol = symbols[0];
    let initial_message = `Ù…Ø¨Ø§Ø±Ø§Ø© Ø¨ÙŠÙ† <@${player1_id}> Ùˆ <@${player2_id}>!`;
    if (player1_id == player2_id) {
      initial_message += '\n_(Ù…Ù† Ø§Ù„Ø®Ø§Ø³Ø±, Ø§Ù†Øª ØªÙ„Ø¹Ø¨ Ù‡Ø°Ø§ Ø§Ù„Ø¯ÙˆØ± Ù…Ø¹ Ù†ÙØ³Ùƒ :joy:)_'
    }
    message.channel.send(`xo! ${initial_message}`)
    .then(console.log("Successful tictactoe introduction"))
    .catch(console.error);
    message.channel.send(':one::two::three:' + '\n' +
                         ':four::five::six:' + '\n' +
                         ':seven::eight::nine:')
    .then((new_message) => {
      grid_message = new_message;
    })
    .then(console.log("Successful xo game initialization"))
    .catch(console.error);
    message.channel.send('ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„... Ø§Ù†ØªØ¸Ø± Ø§Ù„Ø±ÙŠØ¦Ø§ÙƒØ´Ù† :ok:')
    .then(async (new_message) => {
      await new_message.react('1âƒ£');
      await new_message.react('2âƒ£');
      await new_message.react('3âƒ£');
      await new_message.react('4âƒ£');
      await new_message.react('5âƒ£');
      await new_message.react('6âƒ£');
      await new_message.react('7âƒ£');
      await new_message.react('8âƒ£');
      await new_message.react('9âƒ£');
      await new_message.react('ğŸ†—');
      await new_message.edit(`Ø§Ù†Ù‡ Ø¯ÙˆØ± <@${turn_id}> Ø¹Ù„Ø§Ù…ØªÙƒ Ù‡ÙŠ${symbol}`)
      .then((new_new_message) => {
        require('./alpha.js')(client, message, new_new_message, player1_id, player2_id, turn_id, symbol, symbols, grid_message);
      })
      .then(console.log("Successful xo listener initialization"))
      .catch(console.error);
    })
    .then(console.log("Successful xo react initialization"))
    .catch(console.error);
  }
  else {
    message.reply(`_Ù…Ù‡Ù„Ø§ Ù…Ù‡Ù„Ø§_ :anger: \`(Ø§Ø³ØªØ¹Ù…Ù„ Ù‡Ø°Ø§: ${prefix}xo @player1 @player2)\``)
    .then(console.log("Successful error reply"))
    .catch(console.error);
  }
}
 });

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47


client.on("message", message => {
 
  function discoRole() {
    let random = '#'+(Math.random()*0xFFFFFF<<0).toString(16);
    roles.forEach((role) => {
      let theRole = message.guild.roles.find("name", role);
      theRole.edit({color: random}).catch(e => {
        return message.channel.send(":x: **Error:** The role you specified in the `config.json` is either not a role on this server, or his a role higher than the highest role that I have.");
      });
    });
  }
 
  if(message.content.startsWith(prefix + "startdisco")) {
    if(allowedUsers.includes(message.author.id)) {
    setInterval(() => { discoRole(); }, config.ms);
    message.channel.send("```css\nDiscoing...```");
    message.channel.send("Please make sure you read the README, you could get IP banned from discord because of ratelimits.");
  } else {
    message.reply(`You do not have permission to disco. If you have downloaded this bot off of github please go to the config.json and add your user ID to the "allowedUsers" value.`);
  }
} else
 
if(message.content.startsWith(prefix + "stopdisco")) {
  if(allowedUsers.includes(message.author.id)) {
  message.channel.send("I've stopped discoing.");
  setTimeout(() => { console.log(process.exit(0)); }, 300);
} else {
  message.reply(`You do not have permission to disco. If you have downloaded this bot off of github please go to the config.json and add your user ID to the "allowedUsers" value.`);
  }
}
 
});
const config = require('./config.json');
const allowedUsers = config.allowedUsers;
const roles = config.roleToDisco;
 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
 const cuttweet = [
     'ÙƒØª ØªÙˆÙŠØª â€| ØªØ®ÙŠÙ‘Ù„ Ù„Ùˆ Ø£Ù†Ùƒ Ø³ØªØ±Ø³Ù… Ø´ÙŠØ¡ ÙˆØ­ÙŠØ¯ ÙÙŠØµØ¨Ø­ Ø­Ù‚ÙŠÙ‚Ø©ØŒ Ù…Ø§Ø°Ø§ Ø³ØªØ±Ø³Ù…ØŸ',
     'ÙƒØª ØªÙˆÙŠØª | Ø£ÙƒØ«Ø± Ø´ÙŠØ¡ ÙŠÙØ³ÙƒÙØª Ø§Ù„Ø·ÙÙ„ Ø¨Ø±Ø£ÙŠÙƒØŸ',
     'ÙƒØª ØªÙˆÙŠØª | Ø§Ù„Ø­Ø±ÙŠØ© Ù„Ù€ ... ØŸ',
     'ÙƒØª ØªÙˆÙŠØª | Ù‚Ù†Ø§Ø© Ø§Ù„ÙƒØ±ØªÙˆÙ† Ø§Ù„Ù…ÙØ¶Ù„Ø© ÙÙŠ Ø·ÙÙˆÙ„ØªÙƒØŸ',
     'ÙƒØª ØªÙˆÙŠØª â€| ÙƒÙ„Ù…Ø© Ù„Ù„ØµÙØ¯Ø§Ø¹ØŸ',
     'ÙƒØª ØªÙˆÙŠØª â€| Ù…Ø§ Ø§Ù„Ø´ÙŠØ¡ Ø§Ù„Ø°ÙŠ ÙŠÙÙØ§Ø±Ù‚ÙƒØŸ',
     'ÙƒØª ØªÙˆÙŠØª | Ù…ÙˆÙ‚Ù Ù…Ù…ÙŠØ² ÙØ¹Ù„ØªÙ‡ Ù…Ø¹ Ø´Ø®Øµ ÙˆÙ„Ø§ ÙŠØ²Ø§Ù„ ÙŠØ°ÙƒØ±Ù‡ Ù„ÙƒØŸ',
     'ÙƒØª ØªÙˆÙŠØª â€| Ø£ÙŠÙ‡Ù…Ø§ ÙŠÙ†ØªØµØ±ØŒ Ø§Ù„ÙƒØ¨Ø±ÙŠØ§Ø¡ Ø£Ù… Ø§Ù„Ø­Ø¨ØŸ',
     'ÙƒØª ØªÙˆÙŠØª | Ø¨Ø¹Ø¯ Ù¡Ù  Ø³Ù†ÙŠÙ† Ø§ÙŠØ´ Ø¨ØªÙƒÙˆÙ† ØŸ',
     'ÙƒØª ØªÙˆÙŠØª â€| Ù…ÙÙ† Ø£ØºØ±Ø¨ ÙˆØ£Ø¬Ù…Ù„ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„ØªÙŠ Ù…Ø±Øª Ø¹Ù„ÙŠÙƒØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | Ø¹Ù…Ø±Ùƒ Ø´Ù„Øª Ù…ØµÙŠØ¨Ø© Ø¹Ù† Ø´Ø®Øµ Ø¨Ø±ØºØ¨ØªÙƒ ØŸ',
     'ÙƒØª ØªÙˆÙŠØª | Ø£ÙƒØ«Ø± Ø³Ø¤Ø§Ù„ ÙˆØ¬ÙÙ‘Ù‡ Ø¥Ù„ÙŠÙƒ Ù…Ø¤Ø®Ø±Ù‹Ø§ØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø´ÙŠØ¡ Ø§Ù„Ø°ÙŠ ÙŠØ¬Ø¹Ù„Ùƒ ØªØ´Ø¹Ø± Ø¨Ø§Ù„Ø®ÙˆÙØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | ÙˆØ´ ÙŠÙØ³Ø¯ Ø§Ù„ØµØ¯Ø§Ù‚Ø©ØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | Ø´Ø®Øµ Ù„Ø§ØªØ±ÙØ¶ Ù„Ù‡ Ø·Ù„Ø¨Ø§ ØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | ÙƒÙ… Ù…Ø±Ù‡ Ø®Ø³Ø±Øª Ø´Ø®Øµ ØªØ­Ø¨Ù‡ØŸ.',
     'â€ÙƒØª ØªÙˆÙŠØª | ÙƒÙŠÙ ØªØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø§Ø´Ø®Ø§Øµ Ø§Ù„Ø³Ù„Ø¨ÙŠÙŠÙ† ØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | ÙƒÙ„Ù…Ø© ØªØ´Ø¹Ø± Ø¨Ø§Ù„Ø®Ø¬Ù„ Ø§Ø°Ø§ Ù‚ÙŠÙ„Øª Ù„ÙƒØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | Ø¬Ø³Ù…Ùƒ Ø§ÙƒØ¨Ø± Ù…Ù† Ø¹ÙŒÙ…Ø±Ùƒ Ø§Ùˆ Ø§Ù„Ø¹ÙƒØ³Ù‘ ØŸ!',
     'â€ÙƒØª ØªÙˆÙŠØª |Ø£Ù‚ÙˆÙ‰ ÙƒØ°Ø¨Ø© Ù…Ø´Øª Ø¹Ù„ÙŠÙƒ ØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | ØªØªØ£Ø«Ø± Ø¨Ø¯Ù…ÙˆØ¹ Ø´Ø®Øµ ÙŠØ¨ÙƒÙŠ Ù‚Ø¯Ø§Ù…Ùƒ Ù‚Ø¨Ù„ ØªØ¹Ø±Ù Ø§Ù„Ø³Ø¨Ø¨ ØŸ',
     'ÙƒØª ØªÙˆÙŠØª | Ù‡Ù„ Ø­Ø¯Ø« ÙˆØ¶Ø­ÙŠØª Ù…Ù† Ø£Ø¬Ù„ Ø´Ø®ØµÙ Ø£Ø­Ø¨Ø¨ØªØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | Ø£ÙƒØ«Ø± ØªØ·Ø¨ÙŠÙ‚ ØªØ³ØªØ®Ø¯Ù…Ù‡ Ù…Ø¤Ø®Ø±Ù‹Ø§ØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | â€Ø§ÙƒØ«Ø± Ø´ÙŠ ÙŠØ±Ø¶ÙŠÙƒ Ø§Ø°Ø§ Ø²Ø¹Ù„Øª Ø¨Ø¯ÙˆÙ† ØªÙÙƒÙŠØ± ØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | ÙˆØ´ Ù…Ø­ØªØ§Ø¬ Ø¹Ø´Ø§Ù† ØªÙƒÙˆÙ† Ù…Ø¨Ø³ÙˆØ· ØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | Ù…Ø·Ù„Ø¨Ùƒ Ø§Ù„ÙˆØ­ÙŠØ¯ Ø§Ù„Ø­ÙŠÙ† ØŸ',
     'â€ÙƒØª ØªÙˆÙŠØª | Ù‡Ù„ Ø­Ø¯Ø« ÙˆØ´Ø¹Ø±Øª Ø¨Ø£Ù†Ùƒ Ø§Ø±ØªÙƒØ¨Øª Ø£Ø­Ø¯ Ø§Ù„Ø°Ù†ÙˆØ¨ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØµÙŠØ§Ù…ØŸ',
]

 client.on('message', message => {
   if (message.content.startsWith("$$ÙƒØª ØªÙˆÙŠØª")) {
                if(!message.channel.guild) return message.reply('** This command only for servers**');
  var embed = new Discord.RichEmbed()
  .setColor('RANDOM')
   .setThumbnail(message.author.avatarURL) 
 .addField('Ù„Ø¹Ø¨Ù‡ ÙƒØª ØªÙˆÙŠØª' ,
  `${cuttweet[Math.floor(Math.random() * cuttweet.length)]}`)
  message.channel.sendEmbed(embed);
  console.log('[id] Send By: ' + message.author.username)
    }
});

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
client.on('message', message => {
    var prefix = "$";
    
        if (message.author.id === client.user.id) return;
        if (message.guild) {
       let embed = new Discord.RichEmbed()
        let args = message.content.split(' ').slice(1).join(' ');
    if(message.content.split(' ')[0] == prefix + 'bc') {
        if (!args[1]) {
    message.channel.send("**$bc <message>**");
    return;
    }
            message.guild.members.forEach(m => {
       if(!message.member.hasPermission('ADMINISTRATOR')) return;
                var bc = new Discord.RichEmbed()
                .addField('Â» Ø§Ù„Ø³ÙŠØ±ÙØ± :', `${message.guild.name}`)
                .addField('Â» Ø§Ù„Ù…Ø±Ø³Ù„ : ', `${message.author.username}#${message.author.discriminator}`)
                .addField(' Â» Ø§Ù„Ø±Ø³Ø§Ù„Ø© : ', args)
                .setColor('#ff0000')
                // m.send(`[${m}]`);
                m.send(`${m}`,{embed: bc});
            });
        }
        } else {
            return;
        }
    });
    

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
client.on('message', message => {
	
	if(message.author.bot) return;
	if(message.channel.type === 'dm') return;
	
	var command = message.content.toLowerCase().split(" ")[0]; // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
	var args = message.content.toLowerCase().split(" ");
	var userM = message.guild.member(message.mentions.users.first() || message.guild.members.find(m => m.id === args[1]));
	var prefix = '$'; // Ù‡Ù†Ø§ ØªÙ‚Ø¯Ø± ØªØºÙŠØ± Ø§Ù„Ø¨Ø±ÙÙƒØ³ <==================
	
	if(command == prefix + 'role') {
		if(!message.member.hasPermission('MANAGE_ROLES')) return message.channel.send(':no_entry: | You dont have **MANAGE_ROLES** Permission!');
		if(!message.guild.member(client.user).hasPermission('MANAGE_ROLES')) return message.channel.send(':no_entry: | I dont have **MANAGE_ROLES** Permission!');
		if(!message.guild.member(client.user).hasPermission('EMBED_LINKS')) return message.channel.send(':no_entry: | I dont have **EMBED_LINKS** Permission!');

		let roleCommand = new Discord.RichEmbed()
		.setTitle(':white_check_mark: Role Command.')
		.setColor('GREEN')
		.setDescription(`**\n${prefix}role <SOMEONE> <ROLE>**\nâ¥ \`\`For give or delete from some one the role.\`\`\n\n**${prefix}role humans add <ROLE>**\nâ¥ \`\`For give the humans role.\`\`\n\n**${prefix}role humans remove <ROLE>**\nâ¥ \`\`For delete from the humans role.\`\`\n\n**${prefix}role bots add <ROLE>**\nâ¥ \`\`For give the bots role.\`\`\n\n**${prefix}role bots remove <ROLE>**\nâ¥ \`\`For delete from the bots role.\`\`\n\n**${prefix}role all add <ROLE>**\nâ¥ \`\`For give all role.\`\`\n\n**${prefix}role all remove <ROLE>**\nâ¥ \`\`For remove from all role.\`\``)
		.setTimestamp()
		.setFooter(message.author.tag, message.author.avatarURL)

		if(!args[1]) return message.channel.send(roleCommand);
		if(!userM && args[1] !== 'humans' && args[1] !== 'bots' && args[1] !== 'all') return message.channel.send(roleCommand);

		if(userM) {
			var argsRole = message.content.toLowerCase().split(' ').slice(2);
		}else if(args[1] === 'humans' || args[1] === 'bots' || args[1] === 'all') {
			var argsRole = message.content.toLowerCase().split(' ').slice(3); // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
		}

		var getRole = message.mentions.roles.first() || message.guild.roles.find(r => r.id === argsRole) || message.guild.roles.find(r => r.name.toLowerCase().includes(argsRole));

		if(userM) {
			if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
			if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');
			if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Or \`\`DELETE\`\` Any user have or not have **${getRole.name}** role beacuse this role highest from my role!`);
			
			if(!message.guild.member(userM.user).roles.has(getRole.id)) {
				message.guild.member(userM.user).addRole(getRole.id);
				message.channel.send(`:white_check_mark: | Successfully \`\`GIVE\`\` The role **${getRole.name}** To user **${userM.user.tag}**`);
			}else if(message.guild.member(userM.user).roles.has(getRole.id)) {
				message.guild.member(userM.user).removeRole(getRole.id);
				message.channel.send(`:white_check_mark: | Successfully \`\`DELETE\`\` The role **${getRole.name}** From user **${userM.user.tag}**`);
			}
		}else if(args[1] === 'humans') {
			let notArgs = new Discord.RichEmbed()
			.setTitle(':white_check_mark: Role Command.')
			.setColor('GREEN')
			.setDescription(`**\n${prefix}role humans add <ROLE>**\nâ¥ \`\`For give the humans the role.\`\`\n\n**${prefix}role humans remove <ROLE>**\nâ¥ \`\`For delete the role from all humans.\`\``)
			.setTimestamp()
			.setFooter(message.author.tag, message.author.avatarURL)
			
			if(!args[2]) return message.channel.send(notArgs);
			if(!args[3]) return message.channel.send(notArgs); // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
			if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
			if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');

			if(args[2] === 'add') {
				if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Any User the role with name **${getRole.name}** beacuse the role highest then my role!`);
				if(message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user not have **${getRole.name}** role!`);

				let humansSure = new Discord.RichEmbed()
				.setTitle(`:red_circle: Are you sure to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans the role **${getRole.name}**`)
				.setColor('RED')
				.setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, give him the role.\n\nâ = No no, cancel.')
				.setTimestamp()
				.setFooter(message.author.tag, message.author.avatarURL) // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.

				message.channel.send(humansSure).then(msg => {
					msg.react('âœ…').then(() => msg.react('â')) // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.

					let giveHim = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
					let dontGiveHim = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
					let give = msg.createReactionCollector(giveHim, { time: 60000 });
					let dontGive = msg.createReactionCollector(dontGiveHim, { time: 60000 });

					give.on('collect', r => {
						msg.delete();
						message.channel.send(`:timer: | Now you must wait some time to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans the role **${getRole.name}** ...`).then(message1 => {
							message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).forEach(m => {
								message.guild.member(m).addRole(getRole.id);
								setTimeout(() => {
									message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully give all **Humans** The role **${getRole.name}** .`);
								}, 10000)
							});
						});
					});
					dontGive.on('collect', r => { // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
						msg.delete();
						message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
					});
				})
			}else if(args[2] === 'remove') {
				if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`REMOVE\`\` The role with name **${getRole.name}** From any User beacuse the role highest then my role!`);
				if(message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user have **${getRole.name}** role!`);

				let humansSure = new Discord.RichEmbed()
				.setTitle(`:red_circle: Are you sure to remove **${getRole.name}** from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans?`)
				.setColor('RED')
				.setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, remove the role from him.\n\nâ = No no, cancel.')
				.setTimestamp()
				.setFooter(message.author.tag, message.author.avatarURL)

				message.channel.send(humansSure).then(msg => {
					msg.react('âœ…').then(() => msg.react('â')) // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.

					let removeRole = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
					let dontRemoveRole = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
					let remove = msg.createReactionCollector(removeRole, { time: 60000 });
					let dontRemove = msg.createReactionCollector(dontRemoveRole, { time: 60000 });

					remove.on('collect', r => {
						msg.delete();
						message.channel.send(`:timer: | Now you must wait some time to delete from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans the role **${getRole.name}**...`).then(message1 => {
							message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).forEach(m => {
								message.guild.member(m).removeRole(getRole.id);
								setTimeout(() => {
									message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully remove the role **${getRole.name}** From all **Humans** .`);
								}, 10000)
							});
						});
					}); // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
					dontRemove.on('collect', r => {
						msg.delete();
						message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
					});
				})
			} // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
		}else if(args[1] === 'bots') {
		let notArgs = new Discord.RichEmbed()
			.setTitle(':white_check_mark: Role Command.')
			.setColor('GREEN')
			.setDescription(`**\n${prefix}role bots add <ROLE>**\nâ¥ \`\`For give the bots the role.\`\`\n\n**${prefix}role bots remove <ROLE>**\nâ¥ \`\`For delete the role from all bots.\`\``)
			.setTimestamp()
			.setFooter(message.author.tag, message.author.avatarURL) // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
			
			if(!args[2]) return message.channel.send(notArgs);
			if(!args[3]) return message.channel.send(notArgs);
			if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
			if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');

			if(args[2] === 'add') {
				if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Any Bot the role with name **${getRole.name}** beacuse the role highest then my role!`);
				if(message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any bot not have **${getRole.name}** role!`);

				let botsSure = new Discord.RichEmbed()
				.setTitle(`:red_circle: Are you sure to give **${message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).size}** Bots the role **${getRole.name}**`)
				.setColor('RED')
				.setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, give him the role.\n\nâ = No no, cancel.')
				.setTimestamp()
				.setFooter(message.author.tag, message.author.avatarURL)

				message.channel.send(botsSure).then(msg => {
					msg.react('âœ…').then(() => msg.react('â')) // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.

					let giveHim = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
					let dontGiveHim = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
					let give = msg.createReactionCollector(giveHim, { time: 60000 });
					let dontGive = msg.createReactionCollector(dontGiveHim, { time: 60000 });

					give.on('collect', r => {
						msg.delete();
						message.channel.send(`:timer: | Now you must wait some time to give **${message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).size}** Bots the role **${getRole.name}**...`).then(message1 => {
							message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).forEach(b => {
								message.guild.member(b).addRole(getRole.id);
								setTimeout(() => {
									message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully give all **Bots** The role **${getRole.name}** .`);
								}, 10000)
							});
						});
					});
					dontGive.on('collect', r => {
						msg.delete();
						message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
					});
				})
			}else if(args[2] === 'remove') { // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
				if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`REMOVE\`\` The role with name **${getRole.name}** From any Bot beacuse the role highest then my role!`);
				if(message.guild.members.filter(b => message.guild.member(b).roles.has(getRole.id) && b.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any bot have **${getRole.name}** role!`);

				let botsSure = new Discord.RichEmbed()
				.setTitle(`:red_circle: Are you sure to remove **${getRole.name}** from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && m.user.bot).size}** Bots?`)
				.setColor('RED')
				.setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, remove the role from him.\n\nâ = No no, cancel.')
				.setTimestamp()
				.setFooter(message.author.tag, message.author.avatarURL)

				message.channel.send(botsSure).then(msg => {
					msg.react('âœ…').then(() => msg.react('â'))

					let removeRole = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
					let dontRemoveRole = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
					let remove = msg.createReactionCollector(removeRole, { time: 60000 });
					let dontRemove = msg.createReactionCollector(dontRemoveRole, { time: 60000 });

					remove.on('collect', r => {
						msg.delete();
						message.channel.send(`:timer: | Now you must wait some time to delete from **${message.guild.members.filter(b => message.guild.member(b).roles.has(getRole.id) && b.user.bot).size}** Bots the role **${getRole.name}**...`).then(message1 => {
							message.guild.members.filter(b => message.guild.member(b).roles.has(getRole.id) && b.user.bot).forEach(b => {
								message.guild.member(b).removeRole(getRole.id);
								setTimeout(() => {
									message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully remove the role **${getRole.name}** From all **Bots** .`);
								}, 10000)
							});
						});
					});
					dontRemove.on('collect', r => { // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
						msg.delete();
						message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
					});
				})
			}
		}else if(args[1] === 'all') { // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
			let notArgs = new Discord.RichEmbed()
			.setTitle(':white_check_mark: Role Command.')
			.setColor('GREEN')
			.setDescription(`**\n${prefix}role all add <ROLE>**\nâ¥ \`\`For give all the role.\`\`\n\n**${prefix}role all remove <ROLE>**\nâ¥ \`\`For delete the role from all.\`\``)
			.setTimestamp()
			.setFooter(message.author.tag, message.author.avatarURL)
			
			if(!args[2]) return message.channel.send(notArgs);
			if(!args[3]) return message.channel.send(notArgs);
			if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
			if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');

			if(args[2] === 'add') {
				if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Any User the role with name **${getRole.name}** beacuse the role highest then my role!`); // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
				if(message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user not have **${getRole.name}** role!`);

				let allSure = new Discord.RichEmbed()
				.setTitle(`:red_circle: Are you sure to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).size}** The role **${getRole.name}** ?`)
				.setColor('RED')
				.setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, give all the role.\n\nâ = No no, cancel.')
				.setTimestamp()
				.setFooter(message.author.tag, message.author.avatarURL)

				message.channel.send(allSure).then(msg => {
					msg.react('âœ…').then(() => msg.react('â'))

					let giveAll = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
					let dontGiveAll = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
					let give = msg.createReactionCollector(giveAll, { time: 60000 });
					let dontGive = msg.createReactionCollector(dontGiveAll, { time: 60000 });

					give.on('collect', r => {
						msg.delete();
						message.channel.send(`:timer: | Now you must wait some time to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).size}** The role **${getRole.name}** ...`).then(message1 => {
							message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).forEach(m => {
								message.guild.member(m).addRole(getRole.id);
								setTimeout(() => {
									message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully give **All** The role **${getRole.name}** .`);
								}, 10000) // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
							});
						});
					});
					dontGive.on('collect', r => {
						msg.delete();
						message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
					});
				})
			}else if(args[2] === 'remove') {
				if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`REMOVE\`\` The role with name **${getRole.name}** From any User beacuse the role highest then my role!`);
				if(message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user have **${getRole.name}** role!`);

				let allSure = new Discord.RichEmbed() // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
				.setTitle(`:red_circle: Are you sure to remove **${getRole.name}** from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).size}** ?`)
				.setColor('RED')
				.setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, remove the role from him.\n\nâ = No no, cancel.')
				.setTimestamp()
				.setFooter(message.author.tag, message.author.avatarURL)

				message.channel.send(allSure).then(msg => {
					msg.react('âœ…').then(() => msg.react('â'))

					let removeRole = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
					let dontRemoveRole = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id; // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
					let remove = msg.createReactionCollector(removeRole, { time: 60000 });
					let dontRemove = msg.createReactionCollector(dontRemoveRole, { time: 60000 });

					remove.on('collect', r => {
						msg.delete();
						message.channel.send(`:timer: | Now you must wait some time to delete from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).size}** The role **${getRole.name}** ...`).then(message1 => {
							message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).forEach(m => {
								message.guild.member(m).removeRole(getRole.id);
								setTimeout(() => {
									message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully remove the role **${getRole.name}** From **All** .`);
								}, 10000)
							});
						});
					});
					dontRemove.on('collect', r => { // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
						msg.delete();
						message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
					}); // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
				})
			} // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆÙˆØ¯Ø² Alpha Codes.
		}
	}
});

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

client.on("message", async message => {
  if(message.author.bot) return;
  if(message.channel.type === "dm") return;

  let prefix = "$";
  let messageArray = message.content.split (" ");
  let cmd = messageArray[0];
  let args = messageArray.slice(1);



    if(cmd === `${prefix}kick`){



      let kUser = message.guild.member(message.mentions.users.first() || message.guild.members.get(args[0]));
      if(!kUser) return message.channel.send("ÙÙŠÙ† Ø§Ù„Ø¹Ø¶Ùˆ ØŸ");
      let kReason = args.join(" ").slice(22);
      if(!message.member.hasPermission("MANAGE_CHANNELS")) return message.channel.send("Ù…Ø§ Ø¹Ù†Ø¯Ùƒ Ø¨Ø±Ù…Ø´Ù†");
      if(kUser.hasPermission("MANAGE_CHANNELS")) return message.channel.send("Ù…Ø§ ØªÙ‚Ø¯Ø± ØªØ³ÙˆÙŠ ÙƒÙŠÙƒ Ù„Ù„Ø£Ø¯Ù…ÙŠÙ†")

      let kickEmbed = new Discord.RichEmbed()
      .setDescription("~Kick~")
      .setColor("#e56b00")
      .addField("Kicked User", `${kUser} with ID ${kUser.id}`)
      .addField("Kicked By", `<@${message.author.id}> with the id ${message.author.id}`)
      .addField("Kicked In", message.channel)
      .addField("Time", message.createdAt)
      .addField("Reason", kReason);

      let kickChannel = message.guild.channels.find('name', 'kick-ban');
      if(!kickChannel) return message.channel.send("Ù„Ù… Ø§Ø¬Ø¯ Ø±ÙˆÙ… Ø§Ù„ kick-ban");

      message.guild.member(kUser).kick(kReason)
      kickChannel.send(kickEmbed);
    }
    });




client.on("message", async message => {
      if(message.author.bot) return;
      if(message.channel.type === "dm") return;

      let prefix = "$";
      let messageArray = message.content.split (" ");
      let cmd = messageArray[0];
      let args = messageArray.slice(1);



        if(cmd === `${prefix}ban`){



          let kUser = message.guild.member(message.mentions.users.first() || message.guild.members.get(args[0]));
          if(!kUser) return message.channel.send("ÙÙŠÙ† Ø§Ù„Ø¹Ø¶Ùˆ ØŸ");
          let kReason = args.join(" ").slice(22);
          if(!message.member.hasPermission("MANAGE_CHANNELS")) return message.channel.send("Ù…Ø§ Ø¹Ù†Ø¯Ùƒ Ø¨Ø±Ù…Ø´Ù†");
          if(kUser.hasPermission("MANAGE_CHANNELS")) return message.channel.send("Ù…Ø§ ØªÙ‚Ø¯Ø± ØªØ³ÙˆÙŠ Ø¨Ø§Ù† Ù„Ù„Ø£Ø¯Ù…ÙŠÙ†")

          let banEmbed = new Discord.RichEmbed()
          .setDescription("~Ban~")
          .setColor("#8e0505")
          .addField("Banned User", `${bUser} with ID ${bUser.id}`)
          .addField("Banned By", `<@${message.author.id}> with the id ${message.author.id}`)
          .addField("Banned In", message.channel)
          .addField("Time", message.createdAt)
          .addField("Reason", kReason);

          let banChannel = message.guild.channels.find('name', 'kick-ban');
          if(!banChannel) return message.channel.send("Ù„Ù… Ø§Ø¬Ø¯ Ø±ÙˆÙ… kick-ban");

          message.guild.member(bUser).kick(bReason)
          banChannel.send(banEmbed);
        }
        });

	client.on('message', message => {
    var args = message.content.split(/[ ]+/)
    if(message.content.includes('gmail')){
        message.delete()
    return message.reply(`** Ù„Ø§ÙŠÙ…ÙƒÙ†Ùƒ Ù†Ø´Ø± Ø§Ù„Ø¬ÙŠÙ…Ù„  Ù‡Ù†Ø§ **`)
    }
});

client.on('message', message => {
    var args = message.content.split(/[ ]+/)
    if(message.content.includes('snapchat')){
        message.delete()
    return message.reply(`** Ù„Ø§ÙŠÙ…ÙƒÙ†Ùƒ Ù†Ø´Ø± Ø³Ù†Ø§Ø¨ Ø´Ø§Øª  Ù‡Ù†Ø§ **`)
    }
});


client.on('message', message => {
    var args = message.content.split(/[ ]+/)
    if(message.content.includes('instagram')){
        message.delete()
    return message.reply(`** Ù„Ø§ÙŠÙ…ÙƒÙ†Ùƒ Ù†Ø´Ø± Ø§Ù„Ø§Ù†Ø³ØªÙ‚Ø±Ø§Ù… Ù‡Ù†Ø§ **`)
    }
});


client.on('message', message => {
    var args = message.content.split(/[ ]+/)
    if(message.content.includes('twitter')){
        message.delete()
    return message.reply(`** Ù„Ø§ÙŠÙ…ÙƒÙ†Ùƒ  Ù†Ø´Ø± Ø§Ù„ØªÙˆÙŠØªØ± Ù‡Ù†Ø§ **`)
    }
});


client.on('message', message => {
    var args = message.content.split(/[ ]+/)
    if(message.content.includes('facebook')){
        message.delete()
    return message.reply(`** Ù„Ø§ÙŠÙ…ÙƒÙ†Ùƒ Ù†Ø´Ø± Ø§Ù„ÙÙŠØ³ Ø¨ÙˆÙƒ Ù‡Ù†Ø§ **`)
    }
});



client.on('message', message => {
    var args = message.content.split(/[ ]+/)
    if(message.content.includes('youtube')){
        message.delete()
    return message.reply(`** Ù„Ø§ÙŠÙ…ÙƒÙ†Ùƒ Ù†Ø´Ø± Ø§Ø±ÙˆØ§Ø¨Ø· ÙÙŠ Ù‡Ø°Ø§ Ø§Ø³Ø±ÙØ± **`)
    }

});
 
client.on('message', message => {
    if(message.content.includes('discord.gg')){
                                            if(!message.channel.guild) return message.reply('** advertising me on DM ? ğŸ¤”   **');
        if (!message.member.hasPermissions(['ADMINISTRATOR'])){
        message.delete()
    return message.reply(`** No Invite Links :angry: !**`)
    }
}
});

client.on('message', m3a4x => {
  if (m3a4x.content.startsWith('$mute')) {
if (!m3a4x.member.hasPermission("MOVE_MEMBERS")) return m3a4x.channel.send("**Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„Ø®Ø§ØµÙŠÙ‡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡** | â ");
let men = m3a4x.mentions.users.first()
let mas = m3a4x.author
if(!men) return m3a4x.channel.send('`Ù…Ù†Ø´Ù† Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù† ØªØ¹Ø·ÙŠÙ‡ Ù…ÙŠÙˆØª ÙƒØªØ§Ø¨ÙŠ` ');
m3a4x.guild.channels.forEach(c => {
c.overwritePermissions(men.id, {
          SEND_MESSAGES: false
})
    })
const embed = new Discord.RichEmbed()
.setColor("#36393e")
.setDescription(`**
 <@${men.id}>
Ù„Ù‚Ø¯ ØªÙ… Ø§Ø¹Ø·Ø§Ø¦Ùƒ Ù…ÙŠÙˆØª ÙƒØªØ§Ø¨ÙŠ
Ø¨ÙˆØ§Ø³Ø·Ø© : <@${m3a4x.author.id}> **`)
.setThumbnail("https://cdn.discordapp.com/attachments/408952032112803850/452090205793681419/fd684707fc14f41663f15ecebf089f06.png")
          
client.users.get(men.id).sendEmbed(embed)
const Embed11 = new Discord.RichEmbed()
.setColor("#36393e")
.setAuthor(m3a4x.guild.name, m3a4x.guild.iconURL)
.setDescription(`          <@${men.id}>
Ù„Ù‚Ø¯ ØªÙ… Ø§Ø¹Ø·Ø§Ø¦Ù‡ Ø§Ù„Ù…ÙŠÙˆØª Ø§Ù„ÙƒØªØ§Ø¨ÙŠ Ø¨Ù†Ø¬Ø§Ø­
Ø¨ÙˆØ§Ø³Ø·Ø© : <@${m3a4x.author.id}> `)
.setThumbnail("https://cdn.discordapp.com/attachments/408952032112803850/452090205793681419/fd684707fc14f41663f15ecebf089f06.png")
m3a4x.channel.sendEmbed(Embed11).then(m3a4x => {m3a4x.delete(20000)})
    }
})


client.on('message', m3a4x => {
  if (m3a4x.content.startsWith('$unmute')) {
if (!m3a4x.member.hasPermission("MOVE_MEMBERS")) return m3a4x.channel.send("**Ø§Ù†Øª Ù„Ø§ ØªÙ…ØªÙ„Ùƒ Ø§Ù„Ø®Ø§ØµÙŠÙ‡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ù‡** | â ");
 let men = m3a4x.mentions.users.first()
 let mas = m3a4x.author
 if(!men) return m3a4x.channel.send('`Ù…Ù†Ø´Ù† Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø¹Ù†Ù‡ `');
 m3a4x.guild.channels.forEach(c => {
 c.overwritePermissions(men.id, {
         SEND_MESSAGES: true
         })
    })
const embed = new Discord.RichEmbed()
.setColor("#36393e")
.setDescription(`**
 <@${men.id}>
ØªÙ… ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø§Ù„ÙƒØªØ§Ø¨ÙŠ 
Ø¨ÙˆØ§Ø³Ø·Ø© : <@${m3a4x.author.id}> **`)
.setThumbnail("https://cdn.discordapp.com/attachments/408952032112803850/452093541003296788/start-button-hi.png")
          
client.users.get(men.id).sendEmbed(embed)
const Embed11 = new Discord.RichEmbed()
.setColor("#36393e")
.setAuthor(m3a4x.guild.name, m3a4x.guild.iconURL)
.setDescription(`          <@${men.id}>
ØªÙ… ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø§Ù„ÙƒØªØ§Ø¨ÙŠ 
Ø¨ÙˆØ§Ø³Ø·Ø© : <@${m3a4x.author.id}>
`)
.setThumbnail("https://cdn.discordapp.com/attachments/408952032112803850/452093541003296788/start-button-hi.png")
m3a4x.channel.sendEmbed(Embed11).then(m3a4x => {m3a4x.delete(20000)})
    }
})
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20

var prefix = "$"

client.on('message', message => {
  if (message.author.bot) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);

// -say
  if (command === "say") {
          message.delete()
    message.channel.sendMessage(args.join(" ")).catch(console.error);
  }
  
 

if (command == "embed") {
    let say = new Discord.RichEmbed()
    .setDescription(args.join("  "))
    .setColor(0x23b2d6)
    message.channel.sendEmbed(say);
    message.delete();
  }


});

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20

 client.on('message', message => {
        var  user = message.mentions.users.first() || message.author;
    if (message.content.startsWith("$avatar")) {
message.channel.send(`This avatar For ${user} link : ${user.avatarURL}`);
}
});


 client.on("message", message => {
    var prefix = "$"
    if (!message.content.startsWith(prefix)) return;
      let command = message.content.split(" ")[0];
      command = command.slice(prefix.length);
        if(command === "skin") {
                const args = message.content.split(" ").slice(1).join(" ")
        if (!args) return message.channel.send("** Type your skin name **");
        const image = new Discord.Attachment(`https://visage.surgeplay.com/full/256/${args}`, "skin.png");
    message.channel.send(image)
        }
    });
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
const Langs = ['afrikaans', 'albanian', 'amharic', 'arabic', 'armenian', 'azerbaijani', 'bangla', 'basque', 'belarusian', 'bengali', 'bosnian', 'bulgarian', 'burmese', 'catalan', 'cebuano', 'chichewa', 'chinese simplified', 'chinese traditional', 'corsican', 'croatian', 'czech', 'danish', 'dutch', 'english', 'esperanto', 'estonian', 'filipino', 'finnish', 'french', 'frisian', 'galician', 'georgian', 'german', 'greek', 'gujarati', 'haitian creole', 'hausa', 'hawaiian', 'hebrew', 'hindi', 'hmong', 'hungarian', 'icelandic', 'igbo', 'indonesian', 'irish', 'italian', 'japanese', 'javanese', 'kannada', 'kazakh', 'khmer', 'korean', 'kurdish (kurmanji)', 'kyrgyz', 'lao', 'latin', 'latvian', 'lithuanian', 'luxembourgish', 'macedonian', 'malagasy', 'malay', 'malayalam', 'maltese', 'maori', 'marathi', 'mongolian', 'myanmar (burmese)', 'nepali', 'norwegian', 'nyanja', 'pashto', 'persian', 'polish', 'portugese', 'punjabi', 'romanian', 'russian', 'samoan', 'scottish gaelic', 'serbian', 'sesotho', 'shona', 'sindhi', 'sinhala', 'slovak', 'slovenian', 'somali', 'spanish', 'sundanese', 'swahili', 'swedish', 'tajik', 'tamil', 'telugu', 'thai', 'turkish', 'ukrainian', 'urdu', 'uzbek', 'vietnamese', 'welsh', 'xhosa', 'yiddish', 'yoruba', 'zulu'];

client.on('message', message => {
	var prefix = "$";
if (message.content.startsWith(prefix + 'trans')) {
    let args = message.content.split(" ").slice(1);
    if (!args[0]) {
    
        const embed = new Discord.RichEmbed()
            .setColor("FFFFFF")
            .setDescription("**ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙƒØªØ§Ø¨Ø©.**\Ø§Ø³ØªØ¹Ù…Ù„: `-translate <Ø§Ù„ÙƒÙ„Ù…Ø© Ù„ØªØ¨ÙŠ> <Ø§Ø§Ù„ØºØ©>`");

        return message.channel.send(embed);

    } else {

        if (args.length === undefined) {

            return message.channel.send("**ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙƒØªØ§Ø¨Ø©.**\Ø§Ø³ØªØ¹Ù…Ù„: `$translate <Ø§Ù„ÙƒÙ„Ù…Ø© Ù„ØªØ¨ÙŠ> <Ø§Ø§Ù„ØºØ©>`");

        } else {

            let transArg = args[0].toLowerCase();

            args = args.join(' ').slice(1)
            let translation;

            if (!Langs.includes(transArg)) return message.channel.send(`**Language not found.**`);
            args = args.slice(transArg.length);

            translate(args, {
                to: transArg
            }).then(res => {

                const embed = new Discord.RichEmbed()
                    .setAuthor("Translator", client.user.displayAvatarURL)
                    .addField(`Input`, `\`\`\`${args}\`\`\``)
                    .setColor("#42f4c8")
                    .addField(`Output`, `\`\`\`${res.text}\`\`\``);
                return message.channel.send(embed);
            });
        }
    }
}
});
client.login(process.env.BOT_TOKEN);
